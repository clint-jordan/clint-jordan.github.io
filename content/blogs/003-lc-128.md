---
title: The Blind 75 Series
slug: lc-128
description: "Blind 75 #1, LC 128"
longDescription: ""
cardImage: ""
tags: ["leet-code", "blind-75"]
published: 2025-10-03T12:11:05+00:00
# updated: 2025-12-18T02:39:03+00:00
feature: true
draft: true
---

## The LeetCode [Blind 75](https://leetcode.com/problem-list/oizxjoit/)

Evidently this is a popular list of technical interview prep problems. Honestly,
I really hope to find a new job before making it all the way through. If I get
all the way to #75, it's safe to assume that the job search is going very
poorly.

## Why write about LeetCode problems?

Live coding interviews are most certainly one of the most dreaded aspects of the
software engineering field. The vast majority of the LeetCode style problems
given in these interviews have very little connection to real world
applications.  Honestly, professional developers out there, when is the last
time you needed to manually write a sorting algorithm? I'm assuming the answer
to that question is either in college or solely for interiview prep. It's very
easy even for a seasoned professional developer to forget some of the concepts
required to solve these problems because they aren't *explicitly* used very
often in practice.

I can't think of any other field where finding a new job requires dusting off
the old college textbooks. Asking a mid-level software engineer to solve a
difficult LeetCode problem on the spot is similar to asking a mid-level
mechanical engineer to solve a differential equation by hand. Without a
freakishly good memory these things require study time, which isn't necessarily
a bad thing, but we're all living on finite time here. Should you spend some of
your valuable hours revisiting slightly different variations of algorithms that
are are rarely seen in practice, or should you build something useful with that
time?  Every minute spent grinding away on LeetCode is a minute not spent on
real projects. Unfortunately, it's much more likely that you will be asked to
solve these obsure problems rather than "show me something you've built lately."
And this is aside from the other time-consuming aspects of your life like a
current full time job, family, hobbies, etc. Adding LeetCode grinding sessions
to the mix is not only very tough after a full day of work on the keyboard, but
it's probably a really poor use of your time overall (ya know, aside from the
whole obtaining new employment thing).

Now, I do have to admit that these problems are probably the quickest and most
equal way for hiring managers to filter out the unprepared. Then again, just
because a candidate rapidly whipped up a nice depth-first search algorithm from
memory doesn't mean that they're going to make great design decisions for you
down the road. 

Now that the complaining is out of the way, I'll get to the real point, why
write about these problems? Well, one of the best ways to commit something to
your memory is by teaching it to someone else. So here we are, and without
further adue...

## LC-128 Longest Consecutive Sequence

### Problem Statement

Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.

You must write an algorithm that runs in O(n) time.

 

Example 1:

Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.

Example 2:

Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9

Example 3:

Input: nums = [1,0,1,2]
Output: 3

 

Constraints:

* 0 <= nums.length <= 105
* -109 <= nums[i] <= 109

### Solution

```python
class Solution:
  def __init__(self):
    self.cases = [
        ([100,4,200,1,3,2], 4),
        ([1,0,1,2], 3),
        ([], 0),
        ]

  def test(self):
    for i, (inputs, expected) in enumerate(self.cases):
      result = self.longestConsecutive(inputs)
      status = "PASS" if result == expected else "FAIL"
      print(f"Test {i+1}: {status} - Expected {expected}, Got {result}")

    
  def longestConsecutive(self, nums: [int]) -> int:
    nums = set(nums)
    longest = 0
    for n in nums:
      if n-1 not in nums:
        ni = n+1
        while ni in nums:
          ni += 1
        longest = max(longest, ni-n)
    return longest

  
def main():
  s = Solution()
  s.test()

if __name__ == "__main__":
  main()
```